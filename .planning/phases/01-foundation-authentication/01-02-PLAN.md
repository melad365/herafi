---
phase: 01-foundation-authentication
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/auth.ts
  - src/lib/validations/auth.ts
  - src/actions/auth.ts
  - src/app/api/auth/[...nextauth]/route.ts
autonomous: true

must_haves:
  truths:
    - "Auth.js is configured with credentials provider and database sessions"
    - "User can be created in database with hashed password via server action"
    - "User can be authenticated with email and password via server action"
    - "Session is created in database on successful login"
  artifacts:
    - path: "src/lib/auth.ts"
      provides: "Auth.js configuration with credentials provider, database sessions, Prisma adapter"
      exports: ["handlers", "signIn", "signOut", "auth"]
    - path: "src/lib/validations/auth.ts"
      provides: "Shared Zod schemas for login and registration"
      exports: ["loginSchema", "registerSchema"]
    - path: "src/actions/auth.ts"
      provides: "Server actions for register and login"
      exports: ["registerUser", "loginUser"]
    - path: "src/app/api/auth/[...nextauth]/route.ts"
      provides: "Auth.js API route handlers"
      exports: ["GET", "POST"]
  key_links:
    - from: "src/lib/auth.ts"
      to: "src/lib/db.ts"
      via: "PrismaAdapter(prisma)"
      pattern: "PrismaAdapter.*prisma"
    - from: "src/actions/auth.ts"
      to: "src/lib/auth.ts"
      via: "signIn import"
      pattern: "import.*signIn.*from.*auth"
    - from: "src/actions/auth.ts"
      to: "src/lib/db.ts"
      via: "prisma.user queries"
      pattern: "prisma\\.user\\.(findUnique|create)"
    - from: "src/app/api/auth/[...nextauth]/route.ts"
      to: "src/lib/auth.ts"
      via: "handlers export"
      pattern: "handlers.*GET.*POST"
---

<objective>
Configure Auth.js v5 with credentials provider and database sessions, create shared Zod validation schemas, and implement server actions for user registration and login.

Purpose: This is the auth backend — the core logic that makes signup and login work. Without this, the UI forms have nothing to submit to.
Output: Working auth configuration, validation schemas, and server actions that can create users and authenticate them.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-authentication/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Auth.js config, validation schemas, and API route</name>
  <files>
    src/lib/auth.ts
    src/lib/validations/auth.ts
    src/app/api/auth/[...nextauth]/route.ts
  </files>
  <action>
    Create `src/lib/validations/auth.ts` with shared Zod schemas:

    **loginSchema:**
    - email: z.string().email("Invalid email address").transform(email => email.toLowerCase())
    - password: z.string().min(8, "Password must be at least 8 characters")

    **registerSchema:**
    - name: z.string().min(2, "Name must be at least 2 characters").max(50, "Name must be less than 50 characters")
    - email: z.string().email("Invalid email address").transform(email => email.toLowerCase())
    - password: z.string()
        .min(8, "Password must be at least 8 characters")
        .regex(/[A-Z]/, "Password must contain an uppercase letter")
        .regex(/[a-z]/, "Password must contain a lowercase letter")
        .regex(/[0-9]/, "Password must contain a number")

    Export both schemas AND their inferred TypeScript types (LoginInput, RegisterInput).

    Create `src/lib/auth.ts` with Auth.js v5 configuration:
    - Import NextAuth from "next-auth"
    - Import Credentials from "next-auth/providers/credentials"
    - Import PrismaAdapter from "@auth/prisma-adapter"
    - Import prisma from "@/lib/db"
    - Import bcrypt from "bcrypt"
    - Import loginSchema from validations

    Configure NextAuth with:
    - adapter: PrismaAdapter(prisma)
    - session: { strategy: "database", maxAge: 30 * 24 * 60 * 60 } (30 days)
    - pages: { signIn: "/login", error: "/login" }
    - Credentials provider that:
      1. Validates input with loginSchema.safeParse
      2. Finds user by lowercase email via prisma.user.findUnique
      3. Returns null if no user or no hashedPassword
      4. Compares password with bcrypt.compare
      5. Returns { id, email, name } on success, null on failure
    - session callback that attaches user.id to session.user.id
    - Export: handlers, signIn, signOut, auth

    IMPORTANT: Auth.js v5 with Credentials provider and database sessions requires manual session creation. The Credentials provider does NOT work with database sessions out of the box — the adapter's createSession is not called automatically. You must handle this in the signIn callback or use JWT strategy. Research confirms: use `session: { strategy: "jwt" }` instead of "database" for Credentials provider. Update accordingly:
    - session: { strategy: "jwt", maxAge: 30 * 24 * 60 * 60 }
    - Add jwt callback to include user.id in the token
    - Add session callback to include token.sub (user id) in session.user.id

    Create `src/app/api/auth/[...nextauth]/route.ts`:
    ```typescript
    import { handlers } from "@/lib/auth"
    export const { GET, POST } = handlers
    ```
  </action>
  <verify>
    Run `npm run build` — should compile without TypeScript errors.
    Confirm src/lib/auth.ts exports handlers, signIn, signOut, auth.
    Confirm src/lib/validations/auth.ts exports loginSchema, registerSchema, LoginInput, RegisterInput.
    Confirm API route exists at src/app/api/auth/[...nextauth]/route.ts.
  </verify>
  <done>
    Auth.js configured with Credentials provider, JWT sessions (30-day maxAge), Prisma adapter, custom sign-in page at /login. Zod schemas validate email (normalized to lowercase) and password (8+ chars, uppercase, lowercase, number for registration). API route handler wired up.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create server actions for registration and login</name>
  <files>
    src/actions/auth.ts
  </files>
  <action>
    Create `src/actions/auth.ts` with "use server" directive.

    **registerUser action:**
    - Accepts an object with name, email, password (NOT FormData — will be called from React Hook Form)
    - Validates with registerSchema.safeParse
    - On validation failure: return { error: fieldErrors object }
    - Check for existing user by lowercase email (prisma.user.findUnique)
    - If exists: return { error: "An account with this email already exists" }
      (Note: research suggests generic errors to prevent enumeration, but for MVP UX this is acceptable. Add TODO comment noting this could be tightened for production.)
    - Hash password with bcrypt.hash(password, 10)
    - Create user with prisma.user.create({ data: { email (lowercase), name, hashedPassword } })
    - On success: call signIn("credentials", { email, password, redirect: false })
    - Return { success: true } on success
    - Wrap in try/catch, return { error: "Something went wrong. Please try again." } on unexpected errors

    **loginUser action:**
    - Accepts an object with email, password
    - Validates with loginSchema.safeParse
    - On validation failure: return { error: "Invalid email or password" } (generic — don't reveal which field)
    - Call signIn("credentials", { email, password, redirect: false })
    - signIn throws on failure (CredentialsSignin error) — catch it and return { error: "Invalid email or password" }
    - Return { success: true } on success

    Both actions return type: { success?: boolean; error?: string | Record<string, string[]> }

    Import signIn from "@/lib/auth", prisma from "@/lib/db", bcrypt, and schemas from validations.
  </action>
  <verify>
    Run `npm run build` — should compile without TypeScript errors.
    Confirm src/actions/auth.ts exports registerUser and loginUser.
    Confirm both functions are async and have "use server" directive.
  </verify>
  <done>
    registerUser action: validates input, checks for duplicates, hashes password with bcrypt (10 rounds), creates user, auto-signs-in after registration. loginUser action: validates input, calls Auth.js signIn, returns generic error on failure. Both use shared Zod schemas and return structured results.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. Auth.js config exports handlers, signIn, signOut, auth
3. Validation schemas export loginSchema, registerSchema with proper rules
4. Server actions export registerUser, loginUser
5. API route handler exists at /api/auth/[...nextauth]
</verification>

<success_criteria>
- Auth.js v5 configured with Credentials provider and JWT sessions
- Shared Zod schemas validate registration (name, email, strong password) and login (email, password)
- Email normalized to lowercase in all schemas
- registerUser creates user with bcrypt-hashed password and auto-signs-in
- loginUser authenticates via Auth.js signIn with generic error messages
- All files compile and build passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-02-SUMMARY.md`
</output>
