---
phase: 05-real-time-messaging
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/server/socket/handlers/message.ts
  - src/server/socket/handlers/presence.ts
  - src/server/socket/index.ts
  - src/app/api/conversations/route.ts
  - src/app/api/conversations/[conversationId]/messages/route.ts
  - src/app/api/conversations/find-or-create/route.ts
autonomous: true

must_haves:
  truths:
    - "Messages sent via socket are persisted to PostgreSQL"
    - "Both sender and receiver see new messages in real-time via socket events"
    - "Conversation history is retrievable via API"
    - "User can find or create a conversation with another user"
  artifacts:
    - path: "src/server/socket/handlers/message.ts"
      provides: "Socket event handlers for send_message, join_conversation"
      min_lines: 30
    - path: "src/server/socket/handlers/presence.ts"
      provides: "Online/offline presence and typing indicators"
      min_lines: 20
    - path: "src/app/api/conversations/route.ts"
      provides: "GET endpoint listing user's conversations"
      exports: ["GET"]
    - path: "src/app/api/conversations/[conversationId]/messages/route.ts"
      provides: "GET endpoint for conversation message history"
      exports: ["GET"]
    - path: "src/app/api/conversations/find-or-create/route.ts"
      provides: "POST endpoint to find existing or create new conversation"
      exports: ["POST"]
  key_links:
    - from: "src/server/socket/handlers/message.ts"
      to: "prisma.message.create"
      via: "persists message to database before emitting"
      pattern: "prisma\\.message\\.create"
    - from: "src/server/socket/handlers/message.ts"
      to: "io.to(room).emit"
      via: "broadcasts to conversation room after DB save"
      pattern: "io\\.to.*emit.*new_message"
    - from: "src/server/socket/index.ts"
      to: "src/server/socket/handlers/message.ts"
      via: "registers message handlers on connection"
      pattern: "registerMessageHandlers"
---

<objective>
Implement the server-side message handling logic and REST API endpoints for conversation management. This connects the Socket.IO transport (Plan 01) to the database, enabling real-time message delivery with persistence.

Purpose: The messaging backend — socket handlers save and broadcast messages, API routes serve conversation history and enable conversation creation.
Output: Working socket message handlers, conversation listing API, message history API, find-or-create conversation API.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-real-time-messaging/05-RESEARCH.md
@.planning/phases/05-real-time-messaging/05-01-SUMMARY.md
@prisma/schema.prisma
@src/server/socket/index.ts
@src/lib/db.ts
@src/lib/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Socket event handlers for messaging and presence</name>
  <files>
    src/server/socket/handlers/message.ts
    src/server/socket/handlers/presence.ts
    src/server/socket/index.ts
  </files>
  <action>
    **1. Create src/server/socket/handlers/message.ts:**

    Export `registerMessageHandlers(io: Server, socket: Socket)` function.

    Room naming: `getConversationRoom(userId1, userId2)` — sort both IDs, join with `-`. This ensures consistent room names regardless of who initiates.

    Handle these events:

    - `join_conversation({ conversationId })`: Socket joins the room named by conversationId. Verify user is a participant (query DB for conversation.participantIds includes socket.data.userId). If not participant, emit `error` event.

    - `send_message({ conversationId, content })`:
      1. Validate content is non-empty string, max 2000 chars
      2. Verify user is participant of conversation
      3. Save to DB: `prisma.message.create({ data: { conversationId, senderId: socket.data.userId, content } })`
      4. Update conversation `lastMessageAt`: `prisma.conversation.update({ where: { id: conversationId }, data: { lastMessageAt: new Date() } })`
      5. Emit `new_message` to the conversation room with the created message (include sender info: id, name, avatarUrl)
      6. Use `include: { sender: { select: { id: true, name: true, displayName: true, avatarUrl: true } } }` on the create query

    - `leave_conversation({ conversationId })`: Socket leaves the room.

    Import prisma from a server-compatible path. Since the custom server runs outside Next.js, create a direct prisma import. The simplest approach: import `{ prisma }` from `../../lib/db` using relative paths (tsx resolves TypeScript paths).

    **IMPORTANT:** Wait for DB write to complete BEFORE emitting `new_message` to prevent race conditions (Pitfall 4 from research).

    **2. Create src/server/socket/handlers/presence.ts:**

    Export `registerPresenceHandlers(io: Server, socket: Socket)` function.

    Track online users with an in-memory Map: `Map<string, Set<string>>` (userId -> Set of socketIds).

    Handle events:
    - On connection: Add userId->socketId to map. If user was offline (new entry), emit `user_online` to all.
    - On disconnect: Remove socketId from user's set. If set empty (last socket), emit `user_offline` to all, delete from map.
    - `typing_start({ conversationId })`: `socket.to(conversationId).volatile.emit("user_typing", { userId, conversationId })`
    - `typing_stop({ conversationId })`: `socket.to(conversationId).emit("user_stopped_typing", { userId, conversationId })`

    Export the `onlineUsers` Map so it can be queried.

    **3. Update src/server/socket/index.ts:**
    - Import `registerMessageHandlers` and `registerPresenceHandlers`
    - In the `connection` event handler, call both registration functions
    - Call presence connect handler on connection, disconnect handler on socket disconnect
  </action>
  <verify>
    TypeScript compiles without errors. Server starts with `npm run dev`.
    Test manually: Open browser console, connect to socket with valid JWT, emit `send_message` — should see `new_message` event broadcast back.
  </verify>
  <done>
    Socket handlers save messages to DB and broadcast to room. Typing indicators work via volatile events. Online presence tracked in memory.
  </done>
</task>

<task type="auto">
  <name>Task 2: REST API endpoints for conversations</name>
  <files>
    src/app/api/conversations/route.ts
    src/app/api/conversations/[conversationId]/messages/route.ts
    src/app/api/conversations/find-or-create/route.ts
  </files>
  <action>
    **1. Create src/app/api/conversations/route.ts (GET):**
    List all conversations for the authenticated user.
    - Use `auth()` from `@/lib/auth` for authentication
    - Query: `prisma.conversation.findMany({ where: { participantIds: { has: session.user.id } }, orderBy: { lastMessageAt: 'desc' } })`
    - Include the last message: `include: { messages: { orderBy: { createdAt: 'desc' }, take: 1, include: { sender: { select: { id, name, displayName, avatarUrl } } } } }`
    - For each conversation, resolve the "other participant" by filtering participantIds to exclude current user, then query User for their name/avatar
    - Return conversations with otherUser info and last message preview
    - Return 401 if not authenticated

    **2. Create src/app/api/conversations/[conversationId]/messages/route.ts (GET):**
    Load message history for a conversation.
    - Authenticate with `auth()`
    - Verify user is participant of the conversation
    - Query: `prisma.message.findMany({ where: { conversationId }, orderBy: { createdAt: 'asc' }, take: 50, include: { sender: { select: { id, name, displayName, avatarUrl } } } })`
    - Support cursor-based pagination: Accept `?before=messageId` query param. If provided, add `cursor: { id: before }, skip: 1` to query for loading older messages.
    - Also mark unread messages as read: `prisma.message.updateMany({ where: { conversationId, senderId: { not: userId }, readAt: null }, data: { readAt: new Date() } })`
    - Return 403 if user is not a participant, 401 if not authenticated

    **3. Create src/app/api/conversations/find-or-create/route.ts (POST):**
    Find existing conversation between two users or create a new one.
    - Accept `{ otherUserId: string }` in request body
    - Authenticate with `auth()`
    - Validate otherUserId exists and is not the current user
    - Sort IDs: `const participantIds = [session.user.id, otherUserId].sort()`
    - Try to find: `prisma.conversation.findFirst({ where: { participantIds: { equals: participantIds } } })`
    - If not found, create: `prisma.conversation.create({ data: { participantIds } })`
    - Return `{ conversationId }` (the found or created conversation ID)
    - Return 400 if otherUserId is self, 404 if otherUserId doesn't exist, 401 if not authenticated
  </action>
  <verify>
    Start dev server. Test endpoints with curl:
    - `curl http://localhost:3000/api/conversations` (with session cookie) returns conversation list
    - `curl -X POST http://localhost:3000/api/conversations/find-or-create -d '{"otherUserId":"..."}' -H 'Content-Type: application/json'` creates or finds conversation
    All should return proper JSON responses and respect authentication.
  </verify>
  <done>
    API endpoints serve conversation list, message history with pagination, and find-or-create. All endpoints are authenticated and verify user participation.
  </done>
</task>

</tasks>

<verification>
1. Socket `send_message` event saves message to DB and broadcasts `new_message` to room
2. GET `/api/conversations` returns user's conversations with last message preview
3. GET `/api/conversations/[id]/messages` returns paginated message history
4. POST `/api/conversations/find-or-create` creates or finds conversation between two users
5. All endpoints return 401 for unauthenticated requests
</verification>

<success_criteria>
- Messages persist to PostgreSQL via socket handlers
- Real-time delivery via Socket.IO room broadcasting
- Conversation CRUD via REST API
- Typing indicators via volatile socket events
- Online presence tracked in memory
</success_criteria>

<output>
After completion, create `.planning/phases/05-real-time-messaging/05-02-SUMMARY.md`
</output>
