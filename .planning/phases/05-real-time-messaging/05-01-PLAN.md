---
phase: 05-real-time-messaging
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/server/server.ts
  - src/server/socket/middleware/auth.ts
  - src/server/socket/index.ts
  - src/lib/socket.ts
  - src/hooks/useSocket.ts
  - package.json
  - tsconfig.server.json
autonomous: true

must_haves:
  truths:
    - "Socket.IO server starts alongside Next.js on the same HTTP port"
    - "Socket connections are authenticated via JWT token verification"
    - "Conversation and Message models exist in the database"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Conversation and Message models"
      contains: "model Conversation"
    - path: "src/server/server.ts"
      provides: "Custom Next.js + Socket.IO HTTP server"
      min_lines: 20
    - path: "src/server/socket/middleware/auth.ts"
      provides: "JWT authentication for socket connections"
      contains: "jwt.verify"
    - path: "src/server/socket/index.ts"
      provides: "Socket.IO initialization with middleware"
      min_lines: 10
    - path: "src/lib/socket.ts"
      provides: "Client-side socket instance factory"
      min_lines: 5
    - path: "src/hooks/useSocket.ts"
      provides: "React hook for socket connection lifecycle"
      min_lines: 20
  key_links:
    - from: "src/server/server.ts"
      to: "src/server/socket/index.ts"
      via: "imports and initializes Socket.IO on HTTP server"
      pattern: "initSocket.*httpServer"
    - from: "src/server/socket/index.ts"
      to: "src/server/socket/middleware/auth.ts"
      via: "registers auth middleware on io instance"
      pattern: "io\\.use"
    - from: "src/hooks/useSocket.ts"
      to: "src/lib/socket.ts"
      via: "imports socket factory for connection"
      pattern: "import.*socket"
---

<objective>
Set up the real-time messaging infrastructure: database schema for conversations and messages, custom Next.js server with Socket.IO, JWT authentication middleware for socket connections, and client-side socket utilities.

Purpose: This is the foundation layer — database models for persistence, server for real-time transport, and client hooks for React integration. All subsequent plans depend on this.
Output: Working Socket.IO server co-hosted with Next.js, authenticated socket connections, Conversation/Message database models, client-side socket hook.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-real-time-messaging/05-RESEARCH.md
@prisma/schema.prisma
@src/lib/auth.ts
@src/lib/db.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database schema + dependencies + custom server</name>
  <files>
    prisma/schema.prisma
    package.json
    tsconfig.server.json
    src/server/server.ts
    src/server/socket/index.ts
    src/server/socket/middleware/auth.ts
  </files>
  <action>
    **1. Install dependencies:**
    ```bash
    npm install socket.io socket.io-client jsonwebtoken
    npm install -D @types/jsonwebtoken tsx
    ```
    `tsx` is needed to run the TypeScript custom server directly (`tsx src/server/server.ts`).

    **2. Add Conversation and Message models to prisma/schema.prisma:**

    ```prisma
    model Conversation {
      id             String    @id @default(cuid())
      participantIds String[]  // [userId1, userId2] sorted for consistent lookup
      lastMessageAt  DateTime  @default(now())
      createdAt      DateTime  @default(now())

      messages Message[]

      @@index([participantIds])
      @@index([lastMessageAt])
    }

    model Message {
      id             String       @id @default(cuid())
      conversationId String
      conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
      senderId       String
      sender         User         @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
      content        String       @db.Text
      readAt         DateTime?    // Null = unread
      createdAt      DateTime     @default(now())

      @@index([conversationId])
      @@index([senderId])
      @@index([createdAt])
    }
    ```

    Add to User model:
    ```prisma
    sentMessages Message[] @relation("SentMessages")
    ```

    Run `npx prisma db push` to sync schema.

    **3. Create tsconfig.server.json** for the custom server (separate from Next.js tsconfig):
    ```json
    {
      "compilerOptions": {
        "target": "ES2022",
        "module": "ESNext",
        "moduleResolution": "bundler",
        "esModuleInterop": true,
        "strict": true,
        "outDir": "./dist",
        "rootDir": ".",
        "paths": {
          "@/*": ["./src/*"]
        }
      },
      "include": ["src/server/**/*"]
    }
    ```

    **4. Create src/server/socket/middleware/auth.ts:**
    JWT auth middleware that verifies Auth.js tokens on socket connection. Extract token from `socket.handshake.auth.token`. Use `jsonwebtoken` with `process.env.AUTH_SECRET` to verify. Attach `socket.data.userId` on success. Call `next(new Error("Authentication error"))` on failure.

    **5. Create src/server/socket/index.ts:**
    Export `initSocket(httpServer)` function that:
    - Creates `new Server(httpServer)` with CORS allowing same origin
    - Registers auth middleware from `./middleware/auth`
    - Sets up basic connection/disconnect logging
    - Returns the `io` instance for use by handlers (Plan 02)

    **6. Create src/server/server.ts:**
    Custom server following Socket.IO + Next.js pattern from research:
    - Import `next`, `createServer` from `node:http`
    - Import `initSocket` from `./socket`
    - Create Next.js app with `next({ dev, hostname, port })`
    - `app.prepare()` then create HTTP server with `app.getRequestHandler()`
    - Call `initSocket(httpServer)`
    - Listen on port 3000 (or `process.env.PORT`)
    - Log ready message

    **7. Update package.json scripts:**
    ```json
    "dev": "tsx --watch src/server/server.ts",
    "start": "NODE_ENV=production tsx src/server/server.ts"
    ```
    Keep `"build": "next build"` unchanged.
  </action>
  <verify>
    Run `npx prisma db push` — should succeed with Conversation and Message tables created.
    Run `npm run dev` — server should start on port 3000 with "Ready on http://localhost:3000" message.
    Check Socket.IO is listening: `curl http://localhost:3000/socket.io/?EIO=4&transport=polling` should return Socket.IO handshake response (not a 404).
  </verify>
  <done>
    Conversation and Message models in database. Custom server runs Next.js + Socket.IO on same port. Auth middleware verifies JWT on socket connections.
  </done>
</task>

<task type="auto">
  <name>Task 2: Client-side socket utilities</name>
  <files>
    src/lib/socket.ts
    src/hooks/useSocket.ts
  </files>
  <action>
    **1. Create src/lib/socket.ts:**
    Client-side socket instance factory. Mark with `"use client"` pragma.
    - Import `io` from `socket.io-client`
    - Export a `getSocket(token: string)` function that creates a socket instance:
      ```typescript
      io({ auth: { token } })
      ```
    - Do NOT auto-connect on import — connection should be triggered by the hook.

    **2. Create src/hooks/useSocket.ts:**
    React hook managing socket lifecycle. Mark with `"use client"`.
    - Use `useSession()` from `next-auth/react` to get session
    - On session available, create socket via `getSocket()`
    - The token to pass: The Auth.js JWT is in the session cookie, but Socket.IO needs it in the auth handshake. Since Auth.js v5 with JWT strategy stores the token in an httpOnly cookie, we need a workaround:
      - Create an API route at `src/app/api/auth/token/route.ts` that returns the raw JWT from the session cookie. Use `cookies()` from `next/headers` to read the `authjs.session-token` cookie (or `__Secure-authjs.session-token` in production) and return it as JSON.
      - The hook fetches `/api/auth/token` on mount to get the JWT string.
    - Track `isConnected` state via `connect`/`disconnect` events
    - Clean up on unmount: `socket.close()`
    - Return `{ socket, isConnected }`

    **3. Create src/app/api/auth/token/route.ts:**
    Simple GET endpoint:
    - Read the session cookie (`authjs.session-token` for dev, `__Secure-authjs.session-token` for production)
    - Return `{ token }` as JSON
    - Return 401 if no cookie found
  </action>
  <verify>
    TypeScript compilation: `npx tsc --noEmit` on both files should pass (or at least no errors in the new files).
    The hook and socket factory are ready for use by chat components in Plan 03.
  </verify>
  <done>
    Client-side socket factory and React hook exist. API route provides JWT token for socket authentication. Hook manages connection lifecycle with session awareness.
  </done>
</task>

</tasks>

<verification>
1. `npx prisma db push` succeeds — Conversation and Message tables exist
2. `npm run dev` starts custom server with Socket.IO
3. `curl http://localhost:3000/socket.io/?EIO=4&transport=polling` returns Socket.IO handshake
4. New files compile without TypeScript errors
</verification>

<success_criteria>
- Custom server runs Next.js + Socket.IO on port 3000
- Socket connections require JWT authentication
- Conversation and Message models in PostgreSQL
- Client-side hook provides socket instance with session-based auth
- Dev workflow unchanged: `npm run dev` starts everything
</success_criteria>

<output>
After completion, create `.planning/phases/05-real-time-messaging/05-01-SUMMARY.md`
</output>
