---
phase: 05-real-time-messaging
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - src/app/messages/page.tsx
  - src/app/messages/[conversationId]/page.tsx
  - src/components/chat/ConversationList.tsx
  - src/components/chat/MessageList.tsx
  - src/components/chat/MessageInput.tsx
  - src/components/chat/TypingIndicator.tsx
  - src/components/chat/ChatInterface.tsx
  - src/app/u/[username]/page.tsx
  - src/app/gigs/[slug]/page.tsx
  - src/app/dashboard/page.tsx
  - middleware.ts
autonomous: true

must_haves:
  truths:
    - "User can view a list of their conversations at /messages"
    - "User can open a conversation and see message history"
    - "User can type and send a message that appears instantly"
    - "Received messages appear in real-time without page refresh"
    - "User can click 'Message' on a provider profile to start chatting"
    - "User can click 'Message Provider' on a gig page to start chatting"
    - "Messages persist and reload on page refresh"
  artifacts:
    - path: "src/app/messages/page.tsx"
      provides: "Conversation list page"
      min_lines: 20
    - path: "src/app/messages/[conversationId]/page.tsx"
      provides: "Chat conversation page"
      min_lines: 30
    - path: "src/components/chat/ChatInterface.tsx"
      provides: "Main chat component with real-time socket integration"
      min_lines: 50
    - path: "src/components/chat/MessageList.tsx"
      provides: "Scrollable message list with sender differentiation"
      min_lines: 30
    - path: "src/components/chat/MessageInput.tsx"
      provides: "Message input with send button and typing indicator emission"
      min_lines: 25
    - path: "src/components/chat/ConversationList.tsx"
      provides: "Sidebar list of conversations with last message preview"
      min_lines: 25
  key_links:
    - from: "src/components/chat/ChatInterface.tsx"
      to: "src/hooks/useSocket.ts"
      via: "uses socket hook for real-time connection"
      pattern: "useSocket"
    - from: "src/components/chat/ChatInterface.tsx"
      to: "/api/conversations/[conversationId]/messages"
      via: "fetches initial message history"
      pattern: "fetch.*api/conversations"
    - from: "src/components/chat/MessageInput.tsx"
      to: "socket.emit('send_message')"
      via: "sends message via socket"
      pattern: "emit.*send_message"
    - from: "src/app/u/[username]/page.tsx"
      to: "/api/conversations/find-or-create"
      via: "Message button links to or creates conversation"
      pattern: "Message"
    - from: "src/app/gigs/[slug]/page.tsx"
      to: "/api/conversations/find-or-create"
      via: "Message Provider button links to or creates conversation"
      pattern: "Message"
---

<objective>
Build the chat UI layer: conversation list page, chat interface with real-time messaging, and "Message" entry points on provider profiles and gig pages.

Purpose: This is the user-facing layer that ties everything together — the UI that enables real-time communication between users. It connects to the socket infrastructure (Plan 01) and backend handlers/APIs (Plan 02).
Output: Complete chat experience — browse conversations, send/receive messages in real-time, initiate chats from provider profiles and gig pages.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-real-time-messaging/05-RESEARCH.md
@.planning/phases/05-real-time-messaging/05-01-SUMMARY.md
@.planning/phases/05-real-time-messaging/05-02-SUMMARY.md
@src/hooks/useSocket.ts
@src/lib/socket.ts
@src/app/api/conversations/route.ts
@src/app/api/conversations/find-or-create/route.ts
@src/app/u/[username]/page.tsx
@src/app/gigs/[slug]/page.tsx
@src/app/dashboard/page.tsx
@middleware.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Chat pages and components</name>
  <files>
    src/app/messages/page.tsx
    src/app/messages/[conversationId]/page.tsx
    src/components/chat/ConversationList.tsx
    src/components/chat/MessageList.tsx
    src/components/chat/MessageInput.tsx
    src/components/chat/TypingIndicator.tsx
    src/components/chat/ChatInterface.tsx
  </files>
  <action>
    **1. Create src/components/chat/MessageList.tsx** (client component):
    - Receives `messages` array and `currentUserId` string as props
    - Renders messages in a scrollable container (flex-col, overflow-y-auto)
    - Differentiate own messages (right-aligned, orange/amber bg) vs others (left-aligned, gray bg)
    - Show sender name/avatar for received messages
    - Show timestamp (use date-fns `format` or `formatDistanceToNow` for relative time)
    - Auto-scroll to bottom on new messages using `useRef` + `useEffect` with `scrollIntoView`
    - Handle empty state: "No messages yet. Say hello!"

    **2. Create src/components/chat/MessageInput.tsx** (client component):
    - Text input + send button in a form
    - On submit: call `onSend(content)` prop callback, clear input
    - Typing indicator emission: On input change, emit `typing_start` via socket prop. Debounce with 2-second timeout, then emit `typing_stop`. Use a ref for the timeout.
    - Disable send button when input is empty or socket not connected
    - Style: rounded input, orange send button, consistent with app's warm design

    **3. Create src/components/chat/TypingIndicator.tsx** (client component):
    - Shows "[Name] is typing..." with subtle animation (three bouncing dots CSS)
    - Receives `typingUsers` array prop (user objects with name)
    - Renders nothing if no one is typing

    **4. Create src/components/chat/ChatInterface.tsx** (client component):
    - Main orchestrator component. Receives `conversationId`, `initialMessages`, `currentUserId` as props.
    - Uses `useSocket()` hook for real-time connection
    - On mount: emit `join_conversation` with conversationId
    - Listen for `new_message` event: append to messages state (deduplicate by message ID)
    - Listen for `user_typing` / `user_stopped_typing`: maintain typing users state
    - `handleSend(content)`: emit `send_message` via socket with `{ conversationId, content }`
    - On unmount: emit `leave_conversation`
    - Compose: MessageList + TypingIndicator + MessageInput vertically
    - Layout: full height (h-[calc(100vh-theme(spacing.16))]), messages take flex-1, input at bottom

    **5. Create src/components/chat/ConversationList.tsx** (client component):
    - Receives `conversations` array and `currentUserId` as props
    - Each item shows: other user's avatar, name, last message preview (truncated), timestamp
    - Active conversation highlighted (based on URL param or prop)
    - Link each item to `/messages/[conversationId]`
    - Empty state: "No conversations yet"
    - Style: list with hover states, unread indicator (bold text if last message not from current user and unread)

    **6. Create src/app/messages/page.tsx** (server component):
    - Authenticate with `auth()`, redirect to `/login` if not authenticated
    - Fetch conversations via `prisma.conversation.findMany` (same query pattern as API route)
    - Render ConversationList component
    - Page title: "Messages"
    - If no conversations, show friendly empty state

    **7. Create src/app/messages/[conversationId]/page.tsx** (server component):
    - Authenticate, redirect if not authenticated
    - Await params (Next.js 15 async params pattern)
    - Fetch conversation with last 50 messages via Prisma
    - Verify user is participant, redirect to `/messages` if not
    - Mark unread messages as read (updateMany where senderId !== current user and readAt is null)
    - Pass initialMessages and conversationId to ChatInterface client component
    - Show other user's name in a header bar with back link to `/messages`
  </action>
  <verify>
    Start dev server. Navigate to `/messages` — should show conversation list (empty if no conversations).
    If conversations exist (created via API in Plan 02 testing), clicking one should open the chat interface.
    Typing a message and clicking send should emit via socket and appear in the message list.
    Opening the same conversation in two browser tabs (different users) — sending from one should appear in the other in real-time.
  </verify>
  <done>
    Chat pages render at /messages and /messages/[conversationId]. Messages display with sender differentiation. Real-time messaging works via socket. Typing indicators show. Message history loads on page open.
  </done>
</task>

<task type="auto">
  <name>Task 2: Message entry points and navigation</name>
  <files>
    src/app/u/[username]/page.tsx
    src/app/gigs/[slug]/page.tsx
    src/app/dashboard/page.tsx
    middleware.ts
  </files>
  <action>
    **1. Add "Message" button to provider profile page (src/app/u/[username]/page.tsx):**
    - Add a "Message" button next to the provider's info section
    - Only show when viewer is authenticated AND is not viewing their own profile
    - Button behavior: Create a small client component `MessageButton` that:
      - On click, calls `POST /api/conversations/find-or-create` with `{ otherUserId: profileUser.id }`
      - On success, redirects to `/messages/[conversationId]` using `router.push()`
      - Shows loading state during the API call
    - Style: secondary button with chat/message icon, consistent with existing button styles

    **2. Add "Message Provider" button to gig detail page (src/app/gigs/[slug]/page.tsx):**
    - Add a "Message Provider" button in the provider sidebar or below pricing tiers
    - Only show when viewer is authenticated AND is not the gig owner
    - Use the same `MessageButton` component, passing `otherUserId: gig.providerId`
    - Style: outline/secondary button style

    **3. Create the shared MessageButton client component:**
    - Place at `src/components/chat/MessageButton.tsx`
    - Props: `otherUserId: string`
    - Uses `useRouter()` from `next/navigation` for redirect
    - Uses `useSession()` to check auth (hide if not authenticated, or show "Log in to message" link)
    - Handles loading and error states

    **4. Update middleware.ts:**
    - Add `/messages` to the protected pages pattern so unauthenticated users are redirected to login
    - Update the `isProtectedPage` check: add `nextUrl.pathname.startsWith("/messages")`

    **5. Update dashboard (src/app/dashboard/page.tsx):**
    - Add a "Messages" card/link to the dashboard navigation
    - Show basic info: link to `/messages`
    - Consistent with existing dashboard card style (contextual cards pattern)
  </action>
  <verify>
    1. Visit a provider's profile page while logged in as a different user — "Message" button visible
    2. Click "Message" — redirects to `/messages/[conversationId]` (conversation created if needed)
    3. Visit a gig page while logged in as non-owner — "Message Provider" button visible
    4. Visit `/messages` while not logged in — redirects to `/login`
    5. Dashboard shows "Messages" link
  </verify>
  <done>
    "Message" buttons on provider profiles and gig pages. Clicking creates/finds conversation and redirects to chat. Messages route is protected. Dashboard links to messages.
  </done>
</task>

</tasks>

<verification>
1. User can navigate to /messages and see conversation list
2. User can open a conversation and see message history (persists across refresh)
3. User can send a message that appears instantly for both participants
4. User can click "Message" on provider profile to start chatting
5. User can click "Message Provider" on gig page to start chatting
6. Typing indicators appear when other user is typing
7. /messages is protected — redirects to login if not authenticated
</verification>

<success_criteria>
- Complete chat UI at /messages with conversation list and chat interface
- Real-time messaging without page refresh
- Message persistence across page reloads
- Entry points on provider profiles and gig pages
- Warm, consistent styling matching the app's orange/amber theme
- Protected routes for messaging pages
</success_criteria>

<output>
After completion, create `.planning/phases/05-real-time-messaging/05-03-SUMMARY.md`
</output>
