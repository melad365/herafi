---
phase: 02-user-profiles
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/actions/profile.ts
  - src/actions/upload-avatar.ts
  - src/actions/upload-portfolio.ts
  - src/app/profile/edit/page.tsx
  - src/components/forms/AvatarCropModal.tsx
  - src/components/forms/ProfileEditForm.tsx
autonomous: true

must_haves:
  truths:
    - "User can update display name, username, and bio via a single edit form"
    - "User can upload an avatar with circle crop positioning before save"
    - "User can upload portfolio images (up to 6) from the edit page"
    - "Profile changes persist to database after save"
    - "Username uniqueness is enforced with clear error message"
  artifacts:
    - path: "src/actions/profile.ts"
      provides: "Server action for updating profile fields"
      exports: ["updateProfile"]
    - path: "src/actions/upload-avatar.ts"
      provides: "Server action for avatar upload with crop data"
      exports: ["uploadAvatar"]
    - path: "src/actions/upload-portfolio.ts"
      provides: "Server action for portfolio image upload and deletion"
      exports: ["uploadPortfolioImage", "deletePortfolioImage"]
    - path: "src/app/profile/edit/page.tsx"
      provides: "Profile edit page at /profile/edit"
    - path: "src/components/forms/AvatarCropModal.tsx"
      provides: "Avatar crop modal using react-easy-crop"
    - path: "src/components/forms/ProfileEditForm.tsx"
      provides: "Main profile edit form with all fields"
  key_links:
    - from: "src/components/forms/ProfileEditForm.tsx"
      to: "src/actions/profile.ts"
      via: "Server Action form submission"
      pattern: "updateProfile"
    - from: "src/components/forms/AvatarCropModal.tsx"
      to: "src/actions/upload-avatar.ts"
      via: "FormData with cropped blob"
      pattern: "uploadAvatar"
    - from: "src/components/forms/ProfileEditForm.tsx"
      to: "src/actions/upload-portfolio.ts"
      via: "Portfolio image upload handler"
      pattern: "uploadPortfolioImage"
---

<objective>
Build the profile editing experience: server actions for profile/avatar/portfolio updates, the edit page at `/profile/edit`, and the avatar crop modal.

Purpose: This is the primary write path for user profiles — users set their display name, username, bio, avatar, and portfolio images here. All data flows through server actions to Prisma.
Output: Working profile edit page with avatar cropping and portfolio image management.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-user-profiles/02-CONTEXT.md
@.planning/phases/02-user-profiles/02-RESEARCH.md
@.planning/phases/02-user-profiles/02-01-SUMMARY.md
@prisma/schema.prisma
@src/lib/auth.ts
@src/lib/db.ts
@src/lib/file-upload.ts
@src/lib/validations/profile.ts
@src/actions/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create profile, avatar, and portfolio server actions</name>
  <files>src/actions/profile.ts, src/actions/upload-avatar.ts, src/actions/upload-portfolio.ts</files>
  <action>
**File: `src/actions/profile.ts`**

Create a server action for updating profile fields (display name, username, bio):

```ts
"use server";

import { auth } from "@/lib/auth";
import { prisma } from "@/lib/db";
import { profileSchema } from "@/lib/validations/profile";
import { revalidatePath } from "next/cache";

export type ProfileActionState = {
  success: boolean;
  error?: string;
  fieldErrors?: Record<string, string[]>;
};

export async function updateProfile(
  _prevState: ProfileActionState,
  formData: FormData
): Promise<ProfileActionState> {
  const session = await auth();
  if (!session?.user?.id) {
    return { success: false, error: "Not authenticated" };
  }

  const raw = {
    username: formData.get("username") as string,
    displayName: formData.get("displayName") as string,
    bio: formData.get("bio") as string,
  };

  const parsed = profileSchema.safeParse(raw);
  if (!parsed.success) {
    return {
      success: false,
      fieldErrors: parsed.error.flatten().fieldErrors as Record<string, string[]>,
    };
  }

  try {
    await prisma.user.update({
      where: { id: session.user.id },
      data: {
        username: parsed.data.username,
        displayName: parsed.data.displayName,
        bio: parsed.data.bio || null,
      },
    });
  } catch (error: any) {
    // Prisma P2002 = unique constraint violation (username taken)
    if (error?.code === "P2002") {
      return {
        success: false,
        fieldErrors: { username: ["This username is already taken"] },
      };
    }
    return { success: false, error: "Failed to update profile" };
  }

  revalidatePath("/profile/edit");
  revalidatePath(`/u/${parsed.data.username}`);
  return { success: true };
}
```

**File: `src/actions/upload-avatar.ts`**

Server action receiving cropped avatar as FormData blob:

```ts
"use server";

import { auth } from "@/lib/auth";
import { prisma } from "@/lib/db";
import { saveFile, deleteFile } from "@/lib/file-upload";
import { revalidatePath } from "next/cache";

export async function uploadAvatar(formData: FormData) {
  const session = await auth();
  if (!session?.user?.id) {
    return { success: false, error: "Not authenticated" };
  }

  const file = formData.get("avatar") as File;
  if (!file || file.size === 0) {
    return { success: false, error: "No file provided" };
  }

  // Max 2MB for avatars
  if (file.size > 2 * 1024 * 1024) {
    return { success: false, error: "Avatar must be under 2MB" };
  }

  try {
    // Get current avatar to delete old file
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { avatarUrl: true, username: true },
    });

    const avatarUrl = await saveFile(file, "avatars");

    // Delete old avatar if exists
    if (user?.avatarUrl) {
      await deleteFile(user.avatarUrl);
    }

    await prisma.user.update({
      where: { id: session.user.id },
      data: { avatarUrl },
    });

    revalidatePath("/profile/edit");
    if (user?.username) {
      revalidatePath(`/u/${user.username}`);
    }

    return { success: true, avatarUrl };
  } catch (error) {
    return { success: false, error: "Failed to upload avatar" };
  }
}
```

**File: `src/actions/upload-portfolio.ts`**

Server actions for adding and removing portfolio images:

```ts
"use server";

import { auth } from "@/lib/auth";
import { prisma } from "@/lib/db";
import { saveFile, deleteFile } from "@/lib/file-upload";
import { revalidatePath } from "next/cache";

const MAX_PORTFOLIO_IMAGES = 6;

export async function uploadPortfolioImage(formData: FormData) {
  const session = await auth();
  if (!session?.user?.id) {
    return { success: false, error: "Not authenticated" };
  }

  const file = formData.get("image") as File;
  const caption = formData.get("caption") as string | null;

  if (!file || file.size === 0) {
    return { success: false, error: "No file provided" };
  }

  // Max 5MB per portfolio image
  if (file.size > 5 * 1024 * 1024) {
    return { success: false, error: "Image must be under 5MB" };
  }

  // Check count limit
  const count = await prisma.portfolioImage.count({
    where: { userId: session.user.id },
  });
  if (count >= MAX_PORTFOLIO_IMAGES) {
    return { success: false, error: `Maximum ${MAX_PORTFOLIO_IMAGES} portfolio images allowed` };
  }

  try {
    const imageUrl = await saveFile(file, "portfolio");

    const image = await prisma.portfolioImage.create({
      data: {
        userId: session.user.id,
        imageUrl,
        caption: caption || null,
        order: count, // append to end
      },
    });

    revalidatePath("/profile/edit");
    return { success: true, image };
  } catch (error) {
    return { success: false, error: "Failed to upload image" };
  }
}

export async function deletePortfolioImage(imageId: string) {
  const session = await auth();
  if (!session?.user?.id) {
    return { success: false, error: "Not authenticated" };
  }

  const image = await prisma.portfolioImage.findFirst({
    where: { id: imageId, userId: session.user.id },
  });

  if (!image) {
    return { success: false, error: "Image not found" };
  }

  await deleteFile(image.imageUrl);
  await prisma.portfolioImage.delete({ where: { id: imageId } });

  revalidatePath("/profile/edit");
  return { success: true };
}
```

Key patterns:
- All actions check `auth()` first — return error if not authenticated
- File size limits: 2MB avatar, 5MB portfolio
- Portfolio capped at 6 images per user decision
- Old avatar deleted when new one uploaded (no orphaned files)
- `revalidatePath` called after every mutation
- Prisma P2002 error caught for username uniqueness
  </action>
  <verify>
Run `npx tsc --noEmit` — no TypeScript errors in action files.
Confirm all three action files exist and export the expected functions.
  </verify>
  <done>Three server action files created: profile update with username uniqueness, avatar upload with old file cleanup, portfolio upload/delete with 6-image limit.</done>
</task>

<task type="auto">
  <name>Task 2: Build profile edit page with avatar crop modal</name>
  <files>src/app/profile/edit/page.tsx, src/components/forms/ProfileEditForm.tsx, src/components/forms/AvatarCropModal.tsx</files>
  <action>
**File: `src/components/forms/AvatarCropModal.tsx`**

Create a client component that uses `react-easy-crop` for avatar cropping:

- User selects an image file
- Modal opens with circle crop area (react-easy-crop with `cropShape="round"`)
- User can zoom and pan to position the crop
- On confirm, crop the image on a canvas element, export as JPEG blob (0.95 quality)
- Send cropped blob to `uploadAvatar` server action via FormData
- Show loading state during upload
- Close modal on success

Implementation notes:
- Use `react-easy-crop` `Cropper` component with `aspect={1}` and `cropShape="round"`
- On crop complete, use `getCroppedImg` helper that draws to an offscreen canvas at the cropped area coordinates
- Canvas exports as blob via `canvas.toBlob(resolve, "image/jpeg", 0.95)`
- The exported blob gets wrapped in a File object and sent via FormData
- Show the current avatar (or a placeholder icon) as the trigger to open the modal
- Use a simple dialog/modal overlay pattern (fixed positioning, backdrop blur)

**File: `src/components/forms/ProfileEditForm.tsx`**

Create the main profile edit form (client component):

- Single form with fields: username, display name, bio
- Uses `react-hook-form` with Zod resolver (reuse `profileSchema` from validations)
- Submits via `useActionState` calling `updateProfile` server action
- Shows field-level validation errors from both client (react-hook-form) and server (action response)
- Shows success toast/message on successful save
- Pre-populates fields from current user data (passed as props)
- Includes the AvatarCropModal component for avatar management
- Includes a portfolio section: grid of current images with delete buttons + upload button
- Portfolio upload: file input triggers `uploadPortfolioImage`, shows newly added images
- Portfolio delete: calls `deletePortfolioImage`, removes from grid

Form layout (single scrolling page per user decision):
1. Avatar section at top (circle preview + change button)
2. Username field (with "herafi.com/u/" prefix shown)
3. Display name field
4. Bio textarea (with character count)
5. Portfolio section (image grid with add/delete)
6. Single "Save Profile" button at bottom

Style with Tailwind using the warm orange/amber color scheme from Phase 1:
- White card on warm gradient background
- Orange-600 primary buttons, hover orange-700
- Rounded corners, shadow-lg
- Focus rings on inputs (ring-orange-500)

**File: `src/app/profile/edit/page.tsx`**

Server component that:
1. Calls `auth()` to get session
2. Redirects to `/login` if not authenticated
3. Fetches current user data from Prisma (including portfolioImages)
4. Passes user data as props to `ProfileEditForm`
5. Protected page layout consistent with dashboard styling

```tsx
import { auth } from "@/lib/auth";
import { redirect } from "next/navigation";
import { prisma } from "@/lib/db";
import ProfileEditForm from "@/components/forms/ProfileEditForm";

export default async function ProfileEditPage() {
  const session = await auth();
  if (!session?.user?.id) redirect("/login");

  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
    include: { portfolioImages: { orderBy: { order: "asc" } } },
  });

  if (!user) redirect("/login");

  return (
    <div className="min-h-screen bg-gradient-to-br from-orange-50 via-amber-50 to-orange-100">
      <div className="max-w-2xl mx-auto px-6 py-12">
        <h1 className="text-3xl font-bold text-gray-900 mb-8">Edit Profile</h1>
        <ProfileEditForm user={user} />
      </div>
    </div>
  );
}
```
  </action>
  <verify>
1. Run `npx tsc --noEmit` — no TypeScript errors
2. Run `npm run build` — page builds successfully
3. Start dev server, navigate to `/profile/edit` while logged in — page renders with form
4. Test avatar upload: select image, crop circle appears, confirm saves avatar
5. Test profile save: fill fields, click save, data persists on page refresh
6. Test portfolio: upload image appears in grid, delete removes it
  </verify>
  <done>Profile edit page at /profile/edit with: avatar circle crop modal, single form for username/displayName/bio, portfolio image grid with upload/delete, all wired to server actions with validation.</done>
</task>

</tasks>

<verification>
1. `/profile/edit` loads when authenticated, redirects to `/login` when not
2. Avatar crop: select file -> circle crop modal -> confirm -> avatar saved and displayed
3. Profile fields: fill username, display name, bio -> save -> data persists on refresh
4. Username validation: duplicate username shows "already taken" error
5. Portfolio: upload up to 6 images, delete individual images
6. No TypeScript errors (`npx tsc --noEmit`)
</verification>

<success_criteria>
- Profile edit page renders at /profile/edit with warm orange/amber styling
- Avatar crop modal works with circle mask, saves cropped JPEG
- Profile form validates and saves username, display name, bio
- Username uniqueness enforced with user-friendly error
- Portfolio images uploadable (max 6) and deletable
- All changes persist across page refreshes
</success_criteria>

<output>
After completion, create `.planning/phases/02-user-profiles/02-02-SUMMARY.md`
</output>
