---
phase: 11-mock-data-generation
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - prisma/seed.ts
autonomous: true

must_haves:
  truths:
    - "Each provider has 3-8 reviews with varied content and ratings"
    - "Ratings follow bell curve distribution (3.5-5.0 range)"
    - "Reviews have varied lengths (short sentence, medium paragraph, long multi-paragraph)"
    - "Review timestamps fall between order completion and present"
    - "Provider averageRating and totalReviews match actual review data"
    - "Gig averageRating and totalReviews match actual review data"
  artifacts:
    - path: "prisma/seed.ts"
      provides: "Complete seed script with orders, reviews, and aggregates"
      contains: "generateRating"
  key_links:
    - from: "seedOrders()"
      to: "prisma.order.create"
      via: "creates completed orders linking buyers to gigs"
      pattern: "prisma\\.order\\.create"
    - from: "seedReviews()"
      to: "prisma.review.create"
      via: "creates reviews from completed orders"
      pattern: "prisma\\.review\\.create"
    - from: "updateAggregates()"
      to: "prisma.user.update"
      via: "calculates and sets averageRating/totalReviews"
      pattern: "prisma\\.(user|gig)\\.update"
---

<objective>
Populate seedOrders(), seedReviews(), and updateAggregates() functions to complete the mock data generation with realistic order history, varied reviews, and accurate aggregate ratings.

Purpose: Completes the marketplace data pipeline so browsing shows providers with reviews, ratings, and order history.
Output: Fully functional seed script that populates the entire marketplace with realistic data.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-mock-data-generation/11-RESEARCH.md
@.planning/phases/11-mock-data-generation/11-01-SUMMARY.md
@prisma/seed.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Populate seedOrders() with buyer accounts and completed orders</name>
  <files>prisma/seed.ts</files>
  <action>
Populate the seedOrders() function in prisma/seed.ts:

1. **Create 4 buyer accounts** at the start of seedOrders():
   - Loop i = 0 to 3
   - Email: `buyer${i + 1}@herafi-seed.test`
   - Use `prisma.user.upsert()` with:
     - name: faker.person.fullName()
     - username: fakerEN.internet.username().toLowerCase()
     - avatarUrl: `https://api.dicebear.com/9.x/avataaars/svg?seed=${email}`
     - isProvider: false
   - Collect buyers into array

2. **Fetch all gigs** with provider info:
   ```
   const gigs = await prisma.gig.findMany({ include: { provider: true } });
   ```

3. **Create 3-6 completed orders per gig** to ensure enough reviews per provider (3-8 target):
   - For each gig, generate `faker.number.int({ min: 3, max: 6 })` orders
   - Select buyer: `faker.helpers.arrayElement(buyers)` -- ensure buyer is NOT the provider (skip if same, pick next)
   - Select tier: `faker.helpers.arrayElement(['basic', 'standard', 'premium'] as const)`
   - Extract tier data from `(gig.pricingTiers as any)[tier]`
   - Generate realistic timestamps:
     - createdAt: `faker.date.past({ years: 1 })`
     - acceptedAt: createdAt + 1 hour
     - startedAt: createdAt + 1 day
     - completedAt: `faker.date.between({ from: startedAt + 1 day, to: new Date() })`
   - Use `prisma.order.create()` (NOT upsert -- orders don't have a unique constraint suitable for upsert)
   - Set status: 'COMPLETED', paymentConfirmed: true
   - Log total order count

IMPORTANT: Buyers must NOT be providers. Check `buyer.id !== gig.providerId` before creating order. If they match, pick a different buyer.

IMPORTANT: Ensure completedAt is AFTER startedAt. Use date arithmetic to guarantee ordering:
```
const createdAt = faker.date.past({ years: 1 });
const acceptedAt = new Date(createdAt.getTime() + 1000 * 60 * 60);
const startedAt = new Date(acceptedAt.getTime() + 1000 * 60 * 60 * 24);
const completedAt = faker.date.between({ from: new Date(startedAt.getTime() + 1000 * 60 * 60 * 24), to: new Date() });
```
  </action>
  <verify>
Run `npx prisma db seed` and verify:
1. Console shows buyer creation and order count
2. Orders exist in DB linked to gigs and buyers
  </verify>
  <done>
4 buyer accounts created. Each gig has 3-6 completed orders with realistic timestamps, tier selections, and pricing. All orders have COMPLETED status.
  </done>
</task>

<task type="auto">
  <name>Task 2: Populate seedReviews() and updateAggregates() with bell curve ratings</name>
  <files>prisma/seed.ts</files>
  <action>
Add the generateRating() helper and populate seedReviews() and updateAggregates():

1. **Add generateRating() helper** (before seedReviews):
   ```typescript
   function generateRating(): number {
     // Bell curve distribution for realistic marketplace ratings (SEED-17)
     // Rating is Int in schema, so return whole numbers 3-5
     const roll = faker.number.int({ min: 1, max: 100 });
     if (roll <= 25) return 5;       // 25% five-star
     if (roll <= 70) return 4;       // 45% four-star
     if (roll <= 90) return 4;       // 20% four-star (gives 4-star heavy weight)
     return 3;                        // 10% three-star (minimum realistic)
   }
   ```
   Note: Using faker.number.int instead of Math.random() to maintain determinism with faker.seed().

2. **Populate seedReviews()**:
   - Fetch completed orders: `prisma.order.findMany({ where: { status: 'COMPLETED' } })`
   - For each order, 85% chance of review: `faker.datatype.boolean({ probability: 0.85 })`
     (slightly higher than 80% to ensure 3-8 reviews per provider given 3-6 orders per gig)
   - Generate rating using `generateRating()`
   - Vary review content length (SEED-18):
     ```
     const lengthRoll = faker.number.int({ min: 1, max: 3 });
     let content: string;
     if (lengthRoll === 1) content = faker.lorem.sentence();           // Short
     else if (lengthRoll === 2) content = faker.lorem.paragraph();     // Medium
     else content = faker.lorem.paragraphs(2);                         // Long
     ```
   - Set createdAt using `faker.date.between({ from: order.completedAt!, to: new Date() })` (SEED-19)
   - Use `prisma.review.create()` with buyerId, orderId, providerId, gigId, rating, content, createdAt
   - Log review count

3. **Populate updateAggregates()**:
   - **Update provider aggregates:**
     ```
     const providers = await prisma.user.findMany({
       where: { isProvider: true, email: { endsWith: '@herafi-seed.test' } },
       include: { reviewsReceived: { select: { rating: true } } }
     });
     for (const provider of providers) {
       const reviews = provider.reviewsReceived;
       const totalReviews = reviews.length;
       const averageRating = totalReviews > 0
         ? reviews.reduce((sum, r) => sum + r.rating, 0) / totalReviews
         : 0;
       await prisma.user.update({
         where: { id: provider.id },
         data: {
           averageRating: Math.round(averageRating * 10) / 10,
           totalReviews,
         },
       });
     }
     ```
   - **Update gig aggregates** (same pattern but for gigs):
     ```
     const gigs = await prisma.gig.findMany({
       include: { reviews: { select: { rating: true } } }
     });
     for (const gig of gigs) {
       const reviews = gig.reviews;
       const totalReviews = reviews.length;
       const averageRating = totalReviews > 0
         ? reviews.reduce((sum, r) => sum + r.rating, 0) / totalReviews
         : 0;
       await prisma.gig.update({
         where: { id: gig.id },
         data: {
           averageRating: Math.round(averageRating * 10) / 10,
           totalReviews,
         },
       });
     }
     ```
   - Log summary: provider count with ratings, gig count with ratings

IMPORTANT: Check for zero division -- if totalReviews is 0, set averageRating to 0 (Pitfall 3 from research).
IMPORTANT: Review createdAt must be AFTER order completedAt (Pitfall 4 from research).
IMPORTANT: Rating field is Int in schema -- generateRating() must return integers only (Pitfall 5).
  </action>
  <verify>
Run `npx prisma db seed` end-to-end and verify:
1. No errors throughout entire seed process
2. Run verification query:
```
npx tsx -e "
import { PrismaClient } from '@prisma/client';
import { PrismaPg } from '@prisma/adapter-pg';
import { Pool } from 'pg';
import 'dotenv/config';
const pool = new Pool({ connectionString: process.env.DATABASE_URL });
const prisma = new PrismaClient({ adapter: new PrismaPg(pool) });
async function check() {
  const providers = await prisma.user.count({ where: { isProvider: true, email: { endsWith: '@herafi-seed.test' } } });
  const buyers = await prisma.user.count({ where: { isProvider: false, email: { endsWith: '@herafi-seed.test' } } });
  const gigs = await prisma.gig.count();
  const orders = await prisma.order.count({ where: { status: 'COMPLETED' } });
  const reviews = await prisma.review.count();
  const categories = await prisma.gig.groupBy({ by: ['category'], _count: true });
  const providerRatings = await prisma.user.findMany({ where: { isProvider: true, totalReviews: { gt: 0 } }, select: { name: true, averageRating: true, totalReviews: true } });
  console.log('=== Seed Verification ===');
  console.log('Providers:', providers);
  console.log('Buyers:', buyers);
  console.log('Gigs:', gigs);
  console.log('Orders:', orders);
  console.log('Reviews:', reviews);
  console.log('Categories covered:', categories.length, '/ 13');
  console.log('Providers with ratings:', providerRatings.length);
  console.log('Sample ratings:', providerRatings.slice(0, 3).map(p => p.name + ': ' + p.averageRating + ' (' + p.totalReviews + ' reviews)'));
  await pool.end();
}
check();
"
```
3. Verify: 15 providers, 4 buyers, 13 categories, reviews exist, ratings in 3.0-5.0 range
4. Run seed a SECOND time to confirm idempotent (no duplicate key errors)
  </verify>
  <done>
Complete seed script generates: 4 buyers, 3-6 completed orders per gig, reviews with bell curve ratings (3-5 stars), varied review lengths, realistic timestamps, and accurate aggregate ratings on both providers and gigs. Running `npx prisma db seed` twice produces same results without errors.
  </done>
</task>

</tasks>

<verification>
1. `npx prisma db seed` completes without errors
2. 15 providers with averageRating > 0 and totalReviews >= 3
3. 4 buyer accounts exist
4. All 13 categories represented
5. Reviews have varied lengths (check a few manually)
6. Provider averageRating values fall in 3.0-5.0 range
7. Idempotent: running seed twice produces same count of records
8. All SEED-07 through SEED-20 requirements satisfied
</verification>

<success_criteria>
- 4 buyer accounts created for order/review generation
- Each gig has 3-6 completed orders
- 85% of orders have reviews with bell curve ratings
- Review content varies in length (short/medium/long)
- Provider and gig averageRating/totalReviews accurately computed
- Full seed runs idempotently without errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-mock-data-generation/11-02-SUMMARY.md`
</output>
