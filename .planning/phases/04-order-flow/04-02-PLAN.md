---
phase: 04-order-flow
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/actions/orders.ts
autonomous: true

must_haves:
  truths:
    - "Buyer can place an order on a gig they don't own"
    - "Provider can accept, start, and complete their orders"
    - "Both buyer and provider can cancel non-terminal orders"
    - "Self-ordering is prevented (cannot order your own gig)"
    - "Invalid state transitions are rejected with error messages"
  artifacts:
    - path: "src/actions/orders.ts"
      provides: "All order CRUD and state transition server actions"
      exports: ["placeOrder", "acceptOrder", "startOrder", "completeOrder", "cancelOrder", "OrderActionState"]
  key_links:
    - from: "src/actions/orders.ts"
      to: "src/lib/order-state-machine.ts"
      via: "canTransition import"
      pattern: "import.*canTransition.*order-state-machine"
    - from: "src/actions/orders.ts"
      to: "src/lib/validations/order.ts"
      via: "orderSchema import"
      pattern: "import.*orderSchema.*validations/order"
    - from: "src/actions/orders.ts"
      to: "prisma.order"
      via: "database queries"
      pattern: "prisma\\.order\\.(create|update|findUnique)"
---

<objective>
Create server actions for the complete order lifecycle: placing orders, accepting, starting, completing, and cancelling.

Purpose: These server actions are the business logic layer — they enforce authorization (only buyer places orders, only provider manages them), validate state transitions, prevent self-ordering, and snapshot pricing at purchase time.
Output: Single actions/orders.ts file with all order operations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-order-flow/04-RESEARCH.md
@.planning/phases/04-order-flow/04-01-SUMMARY.md
@src/actions/gigs.ts
@src/lib/order-state-machine.ts
@src/lib/validations/order.ts
@src/lib/validations/pricing.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create placeOrder server action</name>
  <files>src/actions/orders.ts</files>
  <action>
Create `src/actions/orders.ts` with 'use server' directive.

Import: auth from '@/lib/auth', prisma from '@/lib/db', orderSchema from '@/lib/validations/order', revalidatePath from 'next/cache', canTransition from '@/lib/order-state-machine', OrderStatus from '@prisma/client', PricingTiers type from '@/lib/validations/pricing'.

Export OrderActionState type: { success: boolean; orderId?: string; error?: string; fieldErrors?: Record<string, string[]> }

Export placeOrder(gigSlug: string, _prevState: OrderActionState, formData: FormData) -> Promise<OrderActionState>:
1. Check session (auth()) — return error if not authenticated
2. Fetch gig by slug with provider select { id: true, isProvider: true }
3. Return error if gig not found
4. Prevent self-ordering: if gig.providerId === session.user.id, return "Cannot order from yourself"
5. Parse formData: selectedTier (string), deliveryNotes (string or null)
6. Validate with orderSchema.safeParse — return fieldErrors if invalid
7. Cast gig.pricingTiers as PricingTiers, extract tier by tierName
8. Return error if tier doesn't exist or tier is not enabled (check tier.enabled !== false for basic, tier?.enabled for standard/premium)
9. Create order with prisma.order.create: buyerId from session, providerId from gig, gigId, selectedTier, tierSnapshot (the full tier object), totalPrice (tier.price), deliveryNotes, status PENDING, paymentConfirmed true
10. revalidatePath('/orders'), revalidatePath('/dashboard'), revalidatePath(`/gigs/${gigSlug}`)
11. Return { success: true, orderId: order.id }
12. Catch errors: return { success: false, error: 'Failed to place order' }

Follow the exact pattern from gigs.ts (same auth check style, same error return shape, same revalidatePath usage).
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors in actions/orders.ts.</verify>
  <done>placeOrder action creates orders with tier snapshot, prevents self-ordering, validates input.</done>
</task>

<task type="auto">
  <name>Task 2: Create order state transition actions</name>
  <files>src/actions/orders.ts</files>
  <action>
Add to the same `src/actions/orders.ts` file:

Export acceptOrder(orderId: string) -> Promise<{ success: boolean; error?: string }>:
1. Check session
2. Fetch order with select { providerId, status }
3. Return error if not found
4. Verify session.user.id === order.providerId (only provider can accept)
5. Validate canTransition(order.status, OrderStatus.ACCEPTED)
6. Update order: status ACCEPTED, acceptedAt new Date()
7. revalidatePath('/dashboard'), revalidatePath('/orders'), revalidatePath(`/orders/${orderId}`)

Export startOrder(orderId: string) — same pattern:
- Provider-only, validates IN_PROGRESS transition, sets startedAt

Export completeOrder(orderId: string) — same pattern:
- Provider-only, validates COMPLETED transition, sets completedAt

Export cancelOrder(orderId: string) — different authorization:
- BOTH buyer and provider can cancel (check buyerId OR providerId matches session)
- Validates CANCELLED transition, sets cancelledAt
- Error message: 'Cannot cancel this order' if terminal state

All actions follow same error handling pattern: try/catch, specific error messages for auth/validation failures, generic for database errors.
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. All 5 actions exported correctly.</verify>
  <done>All order state transition actions enforce authorization, validate transitions via canTransition(), set appropriate timestamps, and revalidate paths.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. placeOrder prevents self-ordering (gig.providerId !== session.user.id)
3. placeOrder snapshots tier pricing at order creation
4. acceptOrder/startOrder/completeOrder only allow provider
5. cancelOrder allows both buyer and provider
6. All state transitions validated through canTransition()
7. All actions revalidate /orders, /dashboard, and order detail paths
</verification>

<success_criteria>
- 5 exported server actions: placeOrder, acceptOrder, startOrder, completeOrder, cancelOrder
- Authorization correctly enforced on every action
- State machine prevents invalid transitions (e.g., COMPLETED -> IN_PROGRESS)
- Tier snapshot preserved in order record
- Self-ordering prevented
</success_criteria>

<output>
After completion, create `.planning/phases/04-order-flow/04-02-SUMMARY.md`
</output>
